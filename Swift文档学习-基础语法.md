基础部分
- 提供了三个基本的集合类型：Array、Set、Dictionary。创建了Tuple，可以让你创建或传递一组数据，可以利用元组返回多个值。
可选（Optional）类型，用于处理值缺失的情况。可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。可选有点像在 Objective-C 中使用 nil ，但是它可以用在任何类型上，不仅仅是类
- 如果你的代码中有不需要改变的值，请使用let关键字将它声明为常量。只将需要改变的值声明为变量
- 一般来说你很少需要写类型注解。如果你在声明常量或者变量的时候赋了一个初始值，Swift 可以推断出这个常量或者变量的类型，请参考 类型安全和类型推断。在上面的例子中，没有给 welcomeMessage 赋初始值，所以变量 welcomeMessage 的类型是通过一个类型注解指定的，而不是通过初始值推断的
- 常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头
- 如果你需要使用与 Swift 保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择
----
- Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义
- 有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句
- 尽量不要使用 UInt，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用 Int，即使你要存储的值已知是非负的。统一使用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断
- Double 精确度很高，至少有15位数字，而 Float 只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 Double
- Swift 是一个类型安全（type safe）的语言，当推断浮点数的类型时，Swift 总是会选择 Double 而不是 Float
- 一个十进制数，没有前缀；一个二进制数，前缀是 0b；一个八进制数，前缀是 0o；一个十六进制数，前缀是 0x
- 0xFp2 表示 15 × 2^2，等于 60.0；0xFp-2 表示 15 × 2^-2，等于 3.75
- 0x代表16进制C代表12后面.3代表小数 所以整数部分应该是应该是 12(16^0) + 0.3(16^-1) 后面的p代表指数，以2为底。所以完整表达式为（12(16^0) + 0.3(16^-1)）*(2^0)
- 结合数字类常量和变量不同于结合数字类字面量。字面量3可以直接和字面量0.14159相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测
----
- 类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名
- 你可以将一个元组的内容分解（decompose）成单独的常量和变量；如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记；你还可以通过下标来访问元组中的单个元素，下标从零开始；当遇到一些相关值的简单分组时，元组是很有用的。元组不适合用来创建复杂的数据结构。如果你的数据结构比较复杂，不要使用元组，用类或结构体去建模
----
- 你可以给可选变量赋值为nil来表示它没有值，nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型
- 当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）
- 在 if 条件语句中使用常量和变量来创建一个可选绑定，仅在 if 语句的句中（body）中才能获取到值。相反，在 guard 语句中使用常量和变量来创建一个可选绑定，仅在 guard 语句外且在语句后才能获取到值
- 第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型
----
断言
- 你可以调用 Swift 标准库的 assert(_:_:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为false的时候这条信息会被显示。
- 如果代码已经检查了条件，你可以使用assertionFailure(_:file:line:)函数来表明断言失败了
- 当一个条件可能为假，但是继续执行代码要求条件必须为真的时候，需要使用先决条件。例如使用先决条件来检查是否下标越界，或者来检查是否将一个正确的参数传给函数。你可以使用全局precondition(_:_:file:line:)函数来写一个先决条件。向这个函数传入一个结果为true或者false的表达式以及一条信息，当表达式的结果为false的时候这条信息会被显示
- 如果你使用 unchecked 模式（-Ounchecked）编译代码，先决条件将不会进行检查。编译器假设所有的先决条件总是为 true（真），他将优化你的代码。然而，fatalError(_:file:line:) 函数总是中断执行，无论你怎么进行优化设定。
你能使用 fatalError(_:file:line:) 函数在设计原型和早期开发阶段，这个阶段只有方法的声明，但是没有具体实现，你可以在方法体中写上 fatalError("Unimplemented")作为具体实现。因为 fatalError 不会像断言和先决条件那样被优化掉，所以你可以确保当代码执行到一个没有被实现的方法时，程序会被中断